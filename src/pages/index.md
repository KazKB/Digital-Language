---
layout: ../layouts/Template.astro
title: "Home - Digital Language"
description: "Introduction to the world of Programming for beginners."
author: "Kaleel Boston"
---
## Programming Notes For Beginners  

Are you interested in learning how to make programs and websites? Well here at <abbr title="Digital Language">DigiLang</abbr> a basic understanding of how to do so is provided. The information provided will be just enough to get your foot into the door. How so? A wide array of topics such as programming languages and javascript frameworks will be covered. You don't worry if you don't understand those terms as you soon will have an idea.  

### Programming Languages  

Programming Languages are the building blocks used to make websites and programs. They are what humans use to communicate and instruct a device on what to do and how to do it. And just like human languages they each have their own structure and grammar (syntax). Some may be similar to others and some may be their own format.  

#### Levels of Programming Languages  

Programming Languages are used in the creation of applications, databases, games, programs, operating systems and websites, just to name a few. These languages fall under different levels that can be further broken down into generations (i.e versions). And they can also be distingued by different categories such as front-end or back-end, interpreted or compiled, and types of language.  
* Low Level (1<sup>st</sup> Generation - 2<sup>nd</sup> Generation)
* High Level (3<sup>rd</sup> Generation - 5<sup>th</sup> Generation)  

#### 1<sup>st</sup> Generation Language (1GL)  

One of the two generations of low level languages is the 1<sup>st</sup> generation. It consists of just one language called *machine langauge*. This is the language a device understands without the need of a translator and speaks. Machine Language is a series of 0s and 1s aka binary that have different meaning. In essence the different combinations can be considered words that the devices communicate by. Also machine language is machine dependent. Meaning that the same combination of 0s and 1s can be two different instructions for two devices. By having this property programmers are required to remember the meaning of each combination for each device. Not only that but as machine language is just binary it is hard to read and debug (correct errors). However, despite being tedious machine language instructions are performed quickly as the device is instantly able to understand it and doesn't need the instructions to be translated.  

#### 2<sup>nd</sup> Generation Language (2GL)  

The other generation of low level languages is 2<sup>nd</sup> generation. Like 1<sup>st</sup> generation, it consists of one language called *assembly language*. Assembly language is a little different from machine language. It uses mnenomics and short keywords for its instructions instead of binary. Thanks to this it is easier for a human to read and debug than machine language. But unfortunately assembly language is still machine dependent and still difficult for a humans to navigate. And as it is not binary needs a translator (assembler) to convert it to machine language.  

#### 3<sup>rd</sup> Generation Languages (3GL)  

The first of the high level languages is 3<sup>rd</sup> generation. A multitude of programming languages fall under this generation. For example: *Basic*, *C++*, *Java* and *Pascal*. 3<sup>rd</sup> generation languages are closer to human language than the low level languages. Words are used to denote instructions making it easier for the programmer to understand and use. And on top of that they are machine independent. Meaning that no matter the device you are coding for the instructions are thing. However, since they are clos to human langaugae instructions are slower to be carried out compared to machine and assembly language. This is because they need compilers and interpretators (translators) to convert the human friendly code (source code) to machine friendly code (machine code).  

#### 4<sup>th</sup> Generation Languages (4GL)  

The second of the high level languages is 4<sup>th</sup> generation. Like 3<sup>rd</sup> generation it also has a multitude of languages. For example: *Perl*, *PHP* and *SQL*. 4<sup>th</sup> generation languages are even closer to human language than the previous generations. They also differ a bit to 3<sup>rd</sup> generation. 3<sup>rd</sup> generation languages have aspects of procedural languages while 4<sup>th</sup> generation languages have aspects of scripting languages. More information on the types of languages will be provided below.  

#### 5<sup>th</sup> Generation Languages (5GL)  

The last of the high level languages is 5<sup>th</sup> generation. Just as the other high level languages this generation has multiple languages in it. For example: *LISP* and *Prolog*. Unlike all the previous generations 5<sup>th</sup> generation takes a spin on programming as it is used for artifiical intillegence. So, intead of specifying what to do and how to do it, it is based on solving problems by providing constraints. Thus it has aspects of logic programming.

### Types of Languages  

Above were the generations of the languages and their respective levels. Outside of the generations, languages can fall under types. This helps determine the structure and principles that the languages follow. The syntax or semantic may be different throughout the type, but the have similar concepts. Also, a lot of languages have traits of multiple types. For example Object-Orientated Programming languages have Procedural and Functional traits.  

There are 5 types of programming languages:  
* Procedural
* Functional
* Object-Orientated Programming (OOP)
* Scripting
* Logic  

#### Procedural Programming Languages  

Procedural languages consist of a sequence of instructions and statements that are carried out in sequential order to get a task done. A set of instructions that relate to a task is called a procedure. Programs written by these languages tend to have one or more of these procedures. Examples of this type of language are *C*, *C++*, *Java* and *Pascal*.  

#### Functional Programming Languages  

Functional languages consist of a group of reusuable instructions and statements that carry out a task called a function. Functions can be thought of as reusable procedures that can be carried out in any order. And just like programs made by procedural languages, programs made by functional languages can consist of one or more functions. Examples of this type of language are *C++*, *Elixir*, *Java*, *Python* and *Scala*.  

#### Object-Orientated Programming Languages  

Object-Orientated Programming Languages consist of objects which are a collection of data and functions called methods that a related to a topic. To better understand you can see an object as a car and the components as the data while the actions it performs as the methods. 
Examples of this type of language are *C#*, *Cobol*, *Java*, *Kotlin* and *Python*.  

#### Scripting Programming Languages  

Scripting Programming Languages are a little different from the others. They are not really used to create applications. But they are used to provide instructions to database, serves, web browsers and other applications and help in the manipulation of data. Examples of this type of language are *JavaScript*, *Perl*, *PHP*, *Python* and *Ruby*.  

#### Logic Programming Languages  

Logic Programming Languages are also different from the others. Instead of telling the program what to do and how to do it, it is provided rules and facts that help it in making decisions on its owns. Examples of this type of language are *Absys*, *Alma-0*, *Datalog*, *LISP* and *Prolog*.  

### Front-End Vs Back-End  

Another way to categorise programming languages is by its purpose. Meaning whether is is front-end or back-end. Front-End languages tend to be more concerned with the look and feel (what the user sees and interact with) of a website or application. Hence why it is called front-end. It is like a waiter or waitress as they are the face of the restaurant. The customer sees them first and interacts with them which then links to the back-end. The back-end languages tend to deal with the movement and manipulation of data. They are like a chef. They work behind the scenes, away from users' eyes. Users have an idea that they are there but don't know what is going on exactly.  

Examples of Front-End Langauges are: *CSS*, *HTML* and *Java*.  

Examples of Back-End Langauges are: *C#*, *JavaScript* and *PHP*.  

### Compiler vs Interpreter  

Another classification of programming languages is if they are compiled or interpretated and this is specific to high level languages. As compilers and interpreters are in essence translators for high level languages to low level languages. Why the need for the so called translation? Well if you remember from earlier it was said that a device speaks and understands machine language. Thus, to a device high languages are a foreign language that they do not understand thus a translator is needed. Source code which is the high level languages instructions is converted to machine code aka object code which is the machine language instructions. One of said translators is called a compiler. Compilers convert all of a program's source code to machine code at the same time. It is the faster of the two, but one will need to retranslate (build) the program again when any changes are made. As for the other translator, it is called an interpreter. It converts source code to machine code line by line, so it is the slower of the two. And unlike a compiler, source code will need to be translated each execution when a interpreter is used.  

Example of Compiled Languages are: *C#*, *C++* and *C*.  

Example of Interpreted Languages are: *JavaScript*, *PHP* and *Python*.  

#### Assembler  

The above were translators for high level to low level, but there is actually a translator for assembly language to machine language. Although both are low level languages, only machine language is understood by a device. Thus assembly language needs to be translated. And the translator for assembly to machine is called an assembler. It is more efficient compared to compilers and interpreters as it translate assembly language instructions to machine language instructions one to one. Where as compilers and interpreters convert one souce code instruction to many machine code instructions.