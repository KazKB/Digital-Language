---
layout: ../layouts/Template.astro
title: "Home - Digital Language"
description: "Introduction or Re-cap of the basics of programming."
author: "Kaleel Boston"
---
## Programming Notes For Beginners  

Are you interested in learning how to make programs and websites? Well here at <abbr title="Digital Language">DigiLang</abbr> a basic understanding of how to do so is provided. The information provided will be just enough to get your foot into the door. How so? A wide array of topics such as programming languages and javascript frameworks will be covered. You don't worry if you don't understand those terms as you will soon have an idea.  

<hr>

### Programming Languages  

Programming Languages are the building blocks used to make websites and programs. They are what humans use to communicate and instruct a device on what to do and how to do it. And just like human languages they each have their own structure and grammar (syntax). Some may be similar to others and some may be their own format.  

#### Levels of Programming Languages  

Programming Languages are used in the creation of applications, databases, games, programs, operating systems and websites, just to name a few. These languages fall under different levels that can be further broken down into generations (i.e versions). And they can also be distinguised by different categories such as front-end or back-end, interpreted or compiled, and types of language.  

* Low Level (1<sup>st</sup> Generation - 2<sup>nd</sup> Generation)
* High Level (3<sup>rd</sup> Generation - 5<sup>th</sup> Generation)  

#### 1<sup>st</sup> Generation Language (1GL)  

One of the two generations of low level languages is the 1<sup>st</sup> generation. It consists of just one language called *machine language*. This is the language a device understands without the need of a translator and speaks. Machine Language is a series of 0s and 1s aka binary that have different meanings. In essence the different combinations can be considered words that the devices communicate by. Also machine language is machine dependent. Meaning that the same combination of 0s and 1s can be two different instructions for two devices. By having this property programmers are required to remember the meaning of each combination for each device. Not only that but as machine language is just binary it is hard to read and debug (correct errors). However, despite being tedious, machine language instructions are performed quickly as the device is instantly able to understand it and doesn't need the instructions to be translated.  

#### 2<sup>nd</sup> Generation Language (2GL)  

The other generation of low level languages is 2<sup>nd</sup> generation. Like 1<sup>st</sup> generation, it consists of one language called *assembly language*. Assembly language is a little different from machine language. It uses mneomics and short keywords for its instructions instead of binary. Thanks to this it is easier for a human to read and debug than machine language. But unfortunately assembly language is still machine dependent and still difficult for a human to navigate. And as it is not binary it needs a translator (assembler) to convert it to machine language.  

#### 3<sup>rd</sup> Generation Languages (3GL)  

The first of the high level languages is 3<sup>rd</sup> generation. A multitude of programming languages fall under this generation. For example: *Basic*, *C++*, *Java* and *Pascal*. 3<sup>rd</sup> generation languages are closer to human language than the low level languages. Words are used to denote instructions making it easier for the programmer to understand and use. And on top of that they are machine independent. Meaning that no matter the device you are programming for the instructions are the same. However, since they are close to human language instructions are slower to be carried out compared to machine and assembly language. This is because they need compilers and interpreteters (translators) to convert the human friendly code (source code) to machine friendly code (machine code).  

#### 4<sup>th</sup> Generation Languages (4GL)  

The second of the high level languages is 4<sup>th</sup> generation. Like 3<sup>rd</sup> generation it also has a multitude of languages. For example: *Perl*, *PHP* and *SQL*. 4<sup>th</sup> generation languages are even closer to human language than the previous generations. They also differ a bit to 3<sup>rd</sup> generation. 3<sup>rd</sup> generation languages have aspects of procedural languages while 4<sup>th</sup> generation languages have aspects of scripting languages. More information on the types of languages will be provided below.  

#### 5<sup>th</sup> Generation Languages (5GL)  

The last of the high level languages is 5<sup>th</sup> generation. Just as the other high level languages this generation has multiple languages in it. For example: *LISP* and *Prolog*. Unlike all the previous generations 5<sup>th</sup> generation takes a spin on programming as it is used for artificial intelligence. So, instead of specifying what to do and how to do it, it is based on solving problems by providing constraints. Thus it has aspects of logic programming.

<hr>

### Types of Languages  

Above were the generations of the languages and their respective levels. Outside of the generations, languages can fall under types. This helps determine the structure and principles that the languages follow. The syntax or semantic may be different throughout the type, but they have similar concepts. Also, a lot of languages have traits of multiple types. For example Object-Oriented Programming languages have Procedural and Functional traits.  

There are 5 types of programming languages:  
* Procedural
* Functional
* Object-Oriented Programming (OOP)
* Scripting
* Logic  

#### Procedural Programming Languages  

Procedural languages consist of a sequence of instructions and statements that are carried out in sequential order to get a task done. A set of instructions that relate to a task is called a procedure. Programs written in these languages tend to have one or more of these procedures. Examples of this type of language are *C*, *C++*, *Java* and *Pascal*.  

#### Functional Programming Languages  

Functional languages consist of a group of reusable instructions and statements that carry out a task called a function. Functions can be thought of as reusable procedures that can be carried out in any order. And just like programs written in procedural languages, programs made by functional languages can consist of one or more functions. Examples of this type of language are *C++*, *Elixir*, *Java*, *Python* and *Scala*.  

#### Object-Oriented Programming Languages  

Object-Oriented Programming Languages consist of objects which are a collection of data and functions called methods that are related to a topic. To better understand you can see an object as a car and the components as the data while the actions it performs as the methods. 
Examples of this type of language are *C#*, *Cobol*, *Java*, *Kotlin* and *Python*.  

#### Scripting Programming Languages  

Scripting Programming Languages are a little different from the others. They are not really used to create applications. But they are used to provide instructions to databases, servers, web browsers and other applications and help in the manipulation of data. Examples of this type of language are *JavaScript*, *Perl*, *PHP*, *Python* and *Ruby*.  

#### Logic Programming Languages  

Logic Programming Languages are also different from the others. Instead of telling the program what to do and how to do it, it is provided rules and facts that help it in making decisions on its own. Examples of this type of language are *Absys*, *Alma-0*, *Datalog*, *LISP* and *Prolog*.  

<hr>

### Front-End Vs Back-End  

Another way to categorise programming languages is by its purpose. Meaning whether it is front-end or back-end. Front-End languages tend to be more concerned with the UI (user interface) and UX (user experience) of a website or application. Hence why it is called front-end. It is like a waiter or waitress as they are the face of the restaurant. The customer sees them first and interacts with them which then links to the back-end. The back-end languages tend to deal with the movement and manipulation of data. They are like chefs. They work behind the scenes, away from users' eyes. Users have an idea that they are there but don't know what is going on exactly.  

Examples of Front-End Languages are: *CSS*, *HTML* and *Java*.  

Examples of Back-End Languages are: *C#*, *JavaScript* and *PHP*.  

<hr>

### Compiler vs Interpreter  

Another classification of programming languages is if they are compiled or interpreted and this is specific to high level languages. As compilers and interpreters are in essence translators for high level languages to low level languages. Why the need for the so called translation? Well if you remember from earlier it was said that a device speaks and understands machine language. Thus, to a device high level languages are foreign languages that they do not understand thus a translator is needed. Source code which is the high level language instructions is converted to machine code aka object code which is the machine language instructions. One of said translators is called a compiler. Compilers convert all of a program's source code to machine code at the same time. It is the faster of the two, but one will need to retranslate (build) the program again when any changes are made. As for the other translator, it is called an interpreter. It converts source code to machine code line by line, so it is the slower of the two. And unlike a compiler, source code will need to be translated each execution when an interpreter is used.  

Example of Compiled Languages are: *C#*, *C++* and *C*.  

Example of Interpreted Languages are: *JavaScript*, *PHP* and *Python*.  

#### Assembler  

The above were translators for high level to low level, but there is actually a translator for assembly language to machine language. Although both are low level languages, only machine language is understood by a device. Thus assembly language needs to be translated. And the translator for assembly to machine is called an assembler. It is more efficient compared to compilers and interpreters as it translates assembly language instructions to machine language instructions one to one. Whereas compilers and interpreters convert one source code instruction to many machine code instructions.

<hr>

### Integrated Development Environment (IDE)  

An integrated development environment aka IDE is a software that combines numerous programming tools into one. Thus IDEs assist programmers by making programming process easier and quicker. Some of the tools involved are text editors (to write the code), debuggers (to discover bugs), and a compiler or intepreter. Obviously there are other tools, but those are the common ones amongst all IDEs. And just like languages, there are multiple IDEs that serve similar purposes but are just slightly different. So, the choice of an IDE comes down to preference which is the same for languages.  

Examples of IDEs are:  
* Visual Studio Code - Lightweight and serves a multitude of uses as one can install extensions to suit their needs.
* Visual Studia - Heavyweight and used for coding in Visual Basic and C#.
* Intellij - Heavyweight and used for coding in Java.
* Pycharm - Heavyweight and used for coding in Python.